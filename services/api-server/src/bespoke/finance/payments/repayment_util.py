import datetime
import decimal
from typing import Any, Callable, Dict, List, Optional, Tuple, cast

from bespoke import errors
from bespoke.date import date_util
from bespoke.db import db_constants, models, models_util
from bespoke.db.db_constants import (LoanStatusEnum, PaymentMethodEnum,
                                     PaymentStatusEnum, ProductType)
from bespoke.db.models import session_scope
from bespoke.finance import contract_util, financial_summary_util, number_util
from bespoke.finance.loans import fee_util, loan_calculator
from bespoke.finance.payments import payment_util, repayment_util_fees
from bespoke.finance.payments.payment_util import RepaymentOption
from bespoke.finance.types import finance_types, per_customer_types
from dateutil import parser
from mypy_extensions import TypedDict
from sqlalchemy.orm.session import Session

# These inputs are seen by the Bank admin before sending them to the /settle_repayment
# handler.
#
# The admin has the ability to modify these values which is why we send it up to them.
#
# These are also the same transactions that get generated by "calculate repayment effect"
# to show the customer and bank admin what the effect of the payment will be.
TransactionInputDict = TypedDict('TransactionInputDict', {
	'amount': float,
	'to_principal': float,
	'to_interest': float,
	'to_fees': float
})

LoanBalanceDict = TypedDict('LoanBalanceDict', {
	'amount': float,
	'outstanding_principal_balance': float,
	'outstanding_interest': float,
	'outstanding_fees': float
})

# Internal data structure to keep track of the LoanDict and the balance information together.
LoanDictAndBalance = TypedDict('LoanDictAndBalance', {
	'loan': models.LoanDict,
	'before_balance': LoanBalanceDict
})

# Information about a loan after a payment has been applied to it.
# We also show the before balance in terms of when the payment settles.
LoanToShowDict = TypedDict('LoanToShowDict', {
	'loan_id': str,
	'loan_identifier': str,
	'transaction': TransactionInputDict,
	'before_loan_balance': LoanBalanceDict,
	'after_loan_balance': LoanBalanceDict
})

RepaymentEffectRespDataDict = TypedDict('RepaymentEffectRespDataDict', {
	'payable_amount_principal': float,
	'payable_amount_interest': float,
	'loans_to_show': List[LoanToShowDict],
	'amount_to_pay': float,
	'amount_as_credit_to_user': float, # If the user overpaid more than what they could possibly owe, we keep this amount as a credit to them.
	'loans_past_due_but_not_selected': List[LoanToShowDict],
})

RepaymentEffectRespDict = TypedDict('RepaymentEffectRespDict', {
	'status': str,
	'data': RepaymentEffectRespDataDict,
})

ScheduleRepaymentReqDict = TypedDict('ScheduleRepaymentReqDict', {
	'company_id': str,
	'payment_id': str,
	'amount': float,
	'payment_date': str, # When the payment was deposited into the bank
	'items_covered': payment_util.PaymentItemsCoveredDict,
})

SettleRepaymentReqDict = TypedDict('SettleRepaymentReqDict', {
	'company_id': str,
	'payment_id': str,
	'amount': float,
	'deposit_date': str, # When the payment was deposited into the bank
	'settlement_date': str, # Effective date of all the transactions as well
	'items_covered': payment_util.PaymentItemsCoveredDict,
	'transaction_inputs': List[TransactionInputDict],
})

def _zero_if_null(val: Optional[float]) -> float:
	if val is None:
		return 0.0
	return val

def _loan_dict_to_loan_balance(loan_dict: models.LoanDict) -> LoanBalanceDict:
	return LoanBalanceDict(
		amount=loan_dict['amount'],
		outstanding_principal_balance=_zero_if_null(
			loan_dict['outstanding_principal_balance']),
		outstanding_interest=_zero_if_null(loan_dict['outstanding_interest']),
		outstanding_fees=_zero_if_null(loan_dict['outstanding_fees'])
	)

def _apply_to(balance: LoanBalanceDict, category: str, amount_left: float) -> Tuple[float, float]:
	if category == 'principal':
		outstanding_amount = balance['outstanding_principal_balance']
	elif category == 'interest':
		outstanding_amount = balance['outstanding_interest']
	elif category == 'fees':
		outstanding_amount = balance['outstanding_fees']
	else:
		raise Exception('Unexpected category to apply to {}'.format(category))

	if outstanding_amount is None:
		amount_left_to_use = amount_left
		amount_applied = 0.0
		return amount_left_to_use, amount_applied
	elif amount_left <= outstanding_amount:
		amount_left_to_use = 0.0
		amount_applied = amount_left
		return amount_left_to_use, amount_applied
	else:
		amount_applied = outstanding_amount
		amount_left_to_use = amount_left - amount_applied
		return amount_left_to_use, amount_applied

@errors.return_error_tuple
def calculate_repayment_effect(
	company_id: str,
	payment_option: str,
	amount: float,
	deposit_date: str,
	settlement_date: str,
	loan_ids: List[str],
	session_maker: Callable
) -> Tuple[RepaymentEffectRespDict, errors.Error]:
	# What loans and fees does would this payment pay off?

	err_details = {'company_id': company_id, 'loan_ids': loan_ids, 'method': 'calculate_repayment_effect'}

	if payment_option == RepaymentOption.CUSTOM_AMOUNT:
		if not number_util.is_number(amount) or amount <= 0:
			raise errors.Error('Payment amount must greater than 0 when payment option is Custom Amount')

	if not deposit_date:
		raise errors.Error('Deposit date must be specified')

	if not settlement_date:
		raise errors.Error('Settlement date must be specified')

	payment_deposit_date = date_util.load_date_str(deposit_date)
	payment_settlement_date = date_util.load_date_str(settlement_date)

	with session_scope(session_maker) as session:
		# Get all contracts associated with company.
		contracts = cast(
			List[models.Contract],
			session.query(models.Contract).filter(
				models.Contract.company_id == company_id
			).all())
		if not contracts:
			raise errors.Error('Cannot calculate repayment effect because no contracts are setup for this company')

		contract_dicts = [c.as_dict() for c in contracts]

	contract_helper, err = contract_util.ContractHelper.build(company_id, contract_dicts)
	if err:
		raise err

	active_contract, err = contract_helper.get_contract(payment_settlement_date)
	if err:
		raise err
	if not active_contract:
		raise errors.Error('No active contract on settlement date')
	product_type, err = active_contract.get_product_type()

	# Figure out how much is due by a particular date
	loan_dicts = []

	with session_scope(session_maker) as session:
		loans = []
		if product_type == ProductType.LINE_OF_CREDIT:
			# TODO(warrenshen):
			# Write a test to check that loans that do not have an origination date
			# set (ex. rejected loans) are NOT fetched.
			# Write a test to check that loans are fetch sorted by [origination date, created at].
			loans = cast(
				List[models.Loan],
				session.query(models.Loan).filter(
					models.Loan.company_id == company_id
				).filter(
					models.Loan.origination_date != None
				).filter(
					models.Loan.closed_at == None
				).order_by(
					models.Loan.origination_date.asc(),
					models.Loan.created_at.asc()
				).all())
		else:
			if not loan_ids:
				raise errors.Error('No loans are selected')

			loans = cast(
				List[models.Loan],
				session.query(models.Loan).filter(
					models.Loan.company_id == company_id
				).filter(
					models.Loan.id.in_(loan_ids)
				).all())

			if len(loans) != len(loan_ids):
				raise errors.Error('Not all selected loans found')

			# TODO(warrenshen): add this check back in and update unit tests.
			# not_funded_loan_ids = [loan.id for loan in loans if not loan.funded_at]
			# if len(not_funded_loan_ids) > 0:
			# 	return None, errors.Error('Not all selected loans are funded')

			closed_loan_ids = [loan.id for loan in loans if loan.closed_at]
			if len(closed_loan_ids) > 0:
				raise errors.Error('Some selected loans are closed already')

		selected_loan_ids = set([])
		for loan in loans:
			selected_loan_ids.add(str(loan.id))
			loan_dicts.append(loan.as_dict())

		loans_past_due = cast(
			List[models.Loan],
			session.query(models.Loan).filter(
				models.Loan.company_id == company_id
			).filter(
				models.Loan.closed_at == None
			).filter(
				models.Loan.adjusted_maturity_date <= payment_settlement_date.isoformat()
			))

		loans_past_due_ids = set([])
		loans_past_due_dicts = []
		for loan_past_due in loans_past_due:
			past_due_loan_id = str(loan_past_due.id)
			loans_past_due_ids.add(past_due_loan_id)
			loans_past_due_dicts.append(loan_past_due.as_dict())

		# Get transactions associated with all the loans selected.
		all_loan_ids = selected_loan_ids.union(loans_past_due_ids)
		transactions = cast(
			List[models.Transaction],
			session.query(models.Transaction).filter(
				models.Transaction.loan_id.in_(all_loan_ids)
			).all())

		# Get the payments associated with the loan
		all_transaction_dicts = []
		all_payment_ids = []
		if transactions:
			for t in transactions:
				all_transaction_dicts.append(t.as_dict())
				all_payment_ids.append(str(t.payment_id))

		existing_payments = cast(
			List[models.Payment],
			session.query(models.Payment).filter(
				models.Payment.id.in_(all_payment_ids)
			).all())

		all_augmented_transactions, err = models_util.get_augmented_transactions(
			all_transaction_dicts, [p.as_dict() for p in existing_payments]
		)
		if err:
			raise err

	# The way we need to calculate "before" the payment is calculate what is due
	# up until the payment date, then insert the payment on that date,
	# then continue the balances on the settlement date, and observe what is remaining
	# after the settlement date.

	# Calculate the loans "before" by running the loan calculator to determine
	# the balance at that particular time.
	report_date = payment_settlement_date
	loan_dict_and_balance_list: List[LoanDictAndBalance] = []

	# Find the before balances for the loans
	fee_accumulator = fee_util.FeeAccumulator()
	financial_summary = financial_summary_util.get_latest_financial_summary(
		company_id=company_id, session=session
	)
	if financial_summary:
		threshold_info = loan_calculator.ThresholdInfoDict(
			day_threshold_met=financial_summary.day_volume_threshold_met
		)
	else:
		threshold_info = loan_calculator.ThresholdInfoDict(
			day_threshold_met=None
		)

	# Calculate old and new loan balances once the payment takes effect for each loan

	# Apply in the order of earliest maturity date to latest maturity date
	# while trying to cover as much of the loan coming due earliest
	loan_dicts.sort(key=lambda l: (l['adjusted_maturity_date'], l['origination_date'], l['created_at']))

	amount_to_pay = 0.0
	amount_as_credit_to_user = 0.0
	loans_to_show = []
	# This says: the user wants to pay some amount of money, and iterate through each loan
	# and determine where this money can be applied.
	#
	# In the custom_amount case, we use up as much of the amount specified by the user.
	# In the pay_in_full and pay_minimum_due case, we dynamically calculate how much the user
	# should pay based on accumulated principal, interest and fees.
	payment_to_include = loan_calculator.IncludedPaymentDict(
		option=payment_option,
		custom_amount=amount,
		custom_amount_split=None,
		deposit_date=payment_deposit_date,
		settlement_date=payment_settlement_date
	)

	for loan_dict in loan_dicts:
		calculator = loan_calculator.LoanCalculator(contract_helper, fee_accumulator)
		transactions_for_loan = loan_calculator.get_transactions_for_loan(
			loan_dict['id'], all_augmented_transactions)
		calculate_result, errs = calculator.calculate_loan_balance(
			threshold_info,
			loan_dict,
			transactions_for_loan,
			report_date,
			payment_to_include=payment_to_include
		)
		if errs:
			raise errors.Error('\n'.join([err.msg for err in errs]))

		loan_after_payment = calculate_result['loan_update']
		payment_effect = calculate_result['payment_effect']
		loan_before_payment = payment_effect['loan_state_before_payment']

		loans_to_show.append(LoanToShowDict(
			loan_id=loan_dict['id'],
			loan_identifier=loan_dict['identifier'],
			transaction=payment_effect['transaction'],
			before_loan_balance=LoanBalanceDict(
				amount=loan_dict['amount'],
				outstanding_principal_balance=loan_before_payment['outstanding_principal'],
				outstanding_interest=loan_before_payment['outstanding_interest'],
				outstanding_fees=loan_before_payment['outstanding_fees']
			),
			after_loan_balance=LoanBalanceDict(
				amount=loan_dict['amount'],
				outstanding_principal_balance=loan_after_payment['outstanding_principal'],
				outstanding_interest=loan_after_payment['outstanding_interest'],
				outstanding_fees=loan_after_payment['outstanding_fees']
			)
		))

		amount_used = payment_effect['transaction']['amount']
		amount_to_pay += amount_used

	if payment_option == RepaymentOption.CUSTOM_AMOUNT:
		amount_as_credit_to_user = amount - amount_to_pay
		# in the custom_amount case, we always say the user will pay the amount
		# they specified, even though only a portion of it may be going to pay off the
		# loans, and some goes to credit
		amount_to_pay = amount

	loans_past_due_but_not_selected = []
	fee_accumulator_past_due = fee_util.FeeAccumulator()
	# List out the before balances for unselected, but overdue loans to show to the user.
	for loan_past_due_dict in loans_past_due_dicts:
		past_due_loan_id = loan_past_due_dict['id']
		if past_due_loan_id in selected_loan_ids:
			continue

		calculator = loan_calculator.LoanCalculator(contract_helper, fee_accumulator_past_due)
		transactions_for_loan = loan_calculator.get_transactions_for_loan(
			past_due_loan_id, all_augmented_transactions)
		calculate_result, errs = calculator.calculate_loan_balance(
			threshold_info,
			loan_past_due_dict,
			transactions_for_loan,
			report_date
		)
		if errs:
			raise errors.Error('\n'.join([err.msg for err in errs]))

		loan_update = calculate_result['loan_update']

		loan_balance = LoanBalanceDict(
			amount=loan_past_due_dict['amount'],
			outstanding_principal_balance=loan_update['outstanding_principal'],
			outstanding_interest=loan_update['outstanding_interest'],
			outstanding_fees=loan_update['outstanding_fees']
		)
		# List out the unselected, but overdue loans, and what their balances will be.
		loans_past_due_but_not_selected.append(LoanToShowDict(
			loan_id=past_due_loan_id,
			loan_identifier=loan_past_due_dict["identifier"],
			transaction=None,
			before_loan_balance=loan_balance,
			after_loan_balance=loan_balance,
		))

	payable_amount_principal = 0.0
	payable_amount_interest = 0.0

	for loan_to_show in loans_to_show:
		before_loan_balance = loan_to_show['before_loan_balance']
		payable_amount_principal += before_loan_balance['outstanding_principal_balance']
		payable_amount_interest += before_loan_balance['outstanding_interest']

	def _round_balance(balance: LoanBalanceDict) -> None:
		balance['amount'] = number_util.round_currency(balance['amount'])
		balance['outstanding_principal_balance'] = number_util.round_currency(
			balance['outstanding_principal_balance'])
		balance['outstanding_interest'] = number_util.round_currency(
			balance['outstanding_interest'])
		balance['outstanding_fees'] = number_util.round_currency(
			balance['outstanding_fees'])

	def _round_loan(cur_loan: LoanToShowDict) -> None:
		tx = cur_loan['transaction']
		if not tx:
			return
		tx['amount'] = number_util.round_currency(tx['amount'])
		tx['to_principal'] = number_util.round_currency(tx['to_principal'])
		tx['to_interest'] = number_util.round_currency(tx['to_interest'])
		tx['to_fees'] = number_util.round_currency(tx['to_fees'])

		_round_balance(cur_loan['before_loan_balance'])
		_round_balance(cur_loan['after_loan_balance'])


	for cur_loan in loans_to_show:
		_round_loan(cur_loan)

	for cur_loan in loans_past_due_but_not_selected:
		_round_loan(cur_loan)

	ordered_loans_to_show: List[LoanToShowDict] = []
	# Note: for Line of Credit we do not show any loans, so we skip it here.
	if product_type != ProductType.LINE_OF_CREDIT:
		ordered_loans_to_show = []
		loan_id_to_loan_to_show = {}

		for cur_loan_to_show in loans_to_show:
			loan_id_to_loan_to_show[cur_loan_to_show['loan_id']] = cur_loan_to_show

		for loan_id in loan_ids:
			ordered_loans_to_show.append(loan_id_to_loan_to_show[loan_id])

	return RepaymentEffectRespDict(
		status='OK',
		data=RepaymentEffectRespDataDict(
			payable_amount_principal=number_util.round_currency(payable_amount_principal),
			payable_amount_interest=number_util.round_currency(payable_amount_interest),
			loans_to_show=ordered_loans_to_show,
			amount_to_pay=number_util.round_currency(amount_to_pay),
			amount_as_credit_to_user=number_util.round_currency(amount_as_credit_to_user),
			loans_past_due_but_not_selected=loans_past_due_but_not_selected,
		),
	), None

@errors.return_error_tuple
def create_repayment(
	company_id: str,
	payment_insert_input: payment_util.PaymentInsertInputDict,
	user_id: str,
	session_maker: Callable,
	is_line_of_credit: bool,
	now_for_test: datetime.datetime = None
) -> Tuple[str, errors.Error]:

	err_details = {'company_id': company_id, 'method': 'create_repayment'}

	payment_method = payment_insert_input['method']
	requested_payment_date = date_util.load_date_str(payment_insert_input['requested_payment_date'])
	requested_amount = payment_insert_input['requested_amount']
	items_covered = payment_insert_input['items_covered']
	company_bank_account_id = payment_insert_input['company_bank_account_id']
	loan_ids = None

	if not payment_method:
		raise errors.Error('Payment method must be specified', details=err_details)

	if not number_util.is_number(requested_amount) or requested_amount <= 0:
		raise errors.Error('Payment requested amount must greater than 0', details=err_details)

	if not requested_payment_date:
		raise errors.Error('Requested payment date must be specified', details=err_details)

	if payment_method == PaymentMethodEnum.REVERSE_DRAFT_ACH and not company_bank_account_id:
		raise errors.Error('Bank account to trigger reverse from must be specified if payment method is Reverse Draft ACH', details=err_details)

	if is_line_of_credit:
		if 'requested_to_principal' not in items_covered or 'requested_to_interest' not in items_covered:
			raise errors.Error('items_covered.requested_to_principal and items_covered.requested_to_interest must be specified', details=err_details)

		requested_to_principal = items_covered['requested_to_principal']
		requested_to_interest = items_covered['requested_to_interest']

		if requested_to_principal is None or requested_to_interest is None:
			raise errors.Error(f'Requested to principal and requested to interest must be specified')

		if not number_util.float_eq(requested_amount, requested_to_principal + requested_to_interest):
			raise errors.Error(f'Requested breakdown of requested_to_principal vs requested_to_interest ({requested_to_principal}, {requested_to_interest}) does not sum up to requested amount ({requested_amount})')
	else:
		if 'loan_ids' not in items_covered:
			raise errors.Error('items_covered.loan_ids must be specified', details=err_details)

		loan_ids = items_covered['loan_ids']
		if len(loan_ids) <= 0:
			raise errors.Error('At least one loan ID must be specified')

	if 'requested_to_account_fees' not in items_covered:
		raise errors.Error('Requested to account fees must be specified', details=err_details)

	payment_id = None

	with session_scope(session_maker) as session:
		loans = []
		if not is_line_of_credit:
			loans = cast(
				List[models.Loan],
				session.query(models.Loan).filter(
					models.Loan.company_id == company_id
				).filter(
					models.Loan.id.in_(loan_ids)
				).all())

			if len(loans) != len(loan_ids):
				raise errors.Error('Not all selected loans found')

			not_funded_loan_ids = [loan.id for loan in loans if not loan.funded_at]
			if len(not_funded_loan_ids) > 0:
				raise errors.Error('Not all selected loans are funded')

			closed_loan_ids = [loan.id for loan in loans if loan.closed_at]
			if len(closed_loan_ids) > 0:
				raise errors.Error('Some selected loans are closed already')

		contract_obj, err = contract_util.get_active_contract_by_company_id(company_id, session)
		if err:
			raise err

		timezone, err = contract_obj.get_timezone_str()
		if err:
			raise err

		is_scheduled = payment_method == PaymentMethodEnum.REVERSE_DRAFT_ACH
		meets_cutoff, meets_cutoff_err = date_util.meets_noon_cutoff(
			requested_payment_date, timezone, now=now_for_test)

		if is_scheduled and meets_cutoff_err:
			raise errors.Error('Cannot set the requested payment date to {} because {}'.format(
				requested_payment_date, meets_cutoff_err))

		# Settlement date should not be set until the banker settles the payment.
		payment_input = payment_util.RepaymentPaymentInputDict(
			payment_method=payment_method,
			requested_amount=requested_amount,
			requested_payment_date=requested_payment_date,
			payment_date=requested_payment_date if payment_method != PaymentMethodEnum.REVERSE_DRAFT_ACH else None,
			items_covered=items_covered,
			company_bank_account_id=company_bank_account_id,
			customer_note=payment_insert_input.get('customer_note')
		)
		payment = payment_util.create_repayment_payment(
			company_id=company_id,
			payment_type=db_constants.PaymentType.REPAYMENT,
			payment_input=payment_input,
			created_by_user_id=user_id
		)
		session.add(payment)
		session.flush()
		payment_id = str(payment.id)

		payment_status = PaymentStatusEnum.SCHEDULED if is_scheduled else PaymentStatusEnum.PENDING

		for loan in loans:
			loan.payment_status = payment_status

	return payment_id, None

@errors.return_error_tuple
def schedule_repayment(
	company_id: str,
	payment_id: str,
	req: ScheduleRepaymentReqDict,
	user_id: str,
	session_maker: Callable,
	is_line_of_credit: bool, # Not used.
) -> Tuple[str, errors.Error]:

	err_details = {'company_id': company_id, 'payment_id': payment_id, 'method': 'schedule_repayment'}

	payment_date = date_util.load_date_str(req['payment_date'])
	payment_amount = req['amount']

	if not number_util.is_number(payment_amount) or payment_amount <= 0:
		raise errors.Error('Payment amount must greater than 0', details=err_details)

	if not payment_date:
		raise errors.Error('Payment date must be specified', details=err_details)

	payment_id = None

	with session_scope(session_maker) as session:
		payment = cast(
			models.Payment,
			session.query(models.Payment).filter(
				models.Payment.id == req['payment_id']
			).first())

		if not payment:
			raise errors.Error('No payment found to schedule transaction', details=err_details)

		################################
		# Validations
		# Note that we do not enforce payment.payment_date >= payment.requested_payment_date.
		# This is because the bank may decide to initiate the reverse draft earlier than when
		# the customer requested the bank to.
		################################
		if payment.method != PaymentMethodEnum.REVERSE_DRAFT_ACH:
			raise errors.Error('Payment method must be Reverse Draft ACH', details=err_details)

		if payment_amount > payment.requested_amount:
			raise errors.Error('Payment amount cannot be greater than requested payment amount', details=err_details)

		payment.amount = decimal.Decimal(payment_amount)
		payment.payment_date = payment_date
		# TODO(warrenshen): look into these statuses, perhaps we need a "Requested"?
		payment_status = PaymentStatusEnum.SCHEDULED

		session.flush()
		payment_id = str(payment.id)

	return payment_id, None

@errors.return_error_tuple
def settle_repayment(
	req: SettleRepaymentReqDict,
	user_id: str,
	session_maker: Callable,
	is_line_of_credit: bool,
) -> Tuple[List[str], errors.Error]:

	err_details = {
		'method': 'settle_repayment',
		'req': req
	}

	company_id = req['company_id']
	payment_id = req['payment_id']

	payment_amount = req['amount']
	deposit_date = date_util.load_date_str(req['deposit_date'])
	settlement_date = date_util.load_date_str(req['settlement_date'])
	items_covered = req['items_covered']
	transaction_inputs = []

	if not number_util.is_currency_rounded(payment_amount):
		raise errors.Error('Amount specified is not rounded to the penny')

	if not deposit_date:
		raise errors.Error('deposit_date must be specified')

	if not settlement_date:
		raise errors.Error('settlement_date must be specified')

	if 'to_account_fees' not in items_covered or 'to_user_credit' not in items_covered:
		raise errors.Error('To account fees and to user credit must be specified', details=err_details)

	to_account_fees = items_covered['to_account_fees']
	to_user_credit = items_covered['to_user_credit']

	if not number_util.is_currency_rounded(to_account_fees):
		raise errors.Error('To account fees specified is not rounded to the penny', details=err_details)

	if not number_util.is_currency_rounded(to_user_credit):
		raise errors.Error('To user credit specified is not rounded to the penny', details=err_details)

	if is_line_of_credit:
		if 'to_principal' not in items_covered or 'to_interest' not in items_covered:
			raise errors.Error('items_covered.to_principal and items_covered.to_interest must be specified', details=err_details)

		to_principal = items_covered['to_principal']
		to_interest = items_covered['to_interest']

		if not number_util.is_currency_rounded(to_principal):
			raise errors.Error('To principal specified is not rounded to the penny', details=err_details)

		if not number_util.is_currency_rounded(to_interest):
			raise errors.Error('To interest specified is not rounded to the penny', details=err_details)

		computed_payment_amount = to_principal + to_interest + to_account_fees + to_user_credit
		if not number_util.float_eq(payment_amount, computed_payment_amount):
			raise errors.Error(f'Sum of amount to principal ({number_util.to_dollar_format(to_principal)}), amount to interest ({number_util.to_dollar_format(to_interest)}), and credit to user ({number_util.to_dollar_format(to_user_credit)}) does not equal payment amount ({number_util.to_dollar_format(payment_amount)})', details=err_details)
	else:
		if not items_covered or 'loan_ids' not in items_covered:
			raise errors.Error('items_covered.loan_ids must be specified', details=err_details)

		transaction_inputs = req['transaction_inputs']

		if not transaction_inputs or len(transaction_inputs) <= 0:
			raise errors.Error('transaction_inputs must be specified', details=err_details)

		transactions_sum = 0.0

		for i in range(len(transaction_inputs)):
			tx_input = transaction_inputs[i]

			if tx_input['to_principal'] < 0 or tx_input['to_interest'] < 0 or tx_input['to_fees'] < 0:
				raise errors.Error('No negative values can be applied using transactions', details=err_details)

			if not number_util.is_currency_rounded(tx_input['to_principal']):
				raise errors.Error('Transaction "{}" to_principal specified is not rounded to the penny'.format(i))

			if not number_util.is_currency_rounded(tx_input['to_interest']):
				raise errors.Error('Transaction "{}" to_interest specified is not rounded to the penny'.format(i))

			if not number_util.is_currency_rounded(tx_input['to_fees']):
				raise errors.Error('Transaction "{}" to_fees specified is not rounded to the penny'.format(i))

			cur_sum = tx_input['to_principal'] + tx_input['to_interest'] + tx_input['to_fees']
			if not number_util.float_eq(cur_sum, tx_input['amount']):
				raise errors.Error('Transaction at index {} does not balance with itself'.format(i), details=err_details)

			transactions_sum += cur_sum

		computed_payment_amount = transactions_sum + to_account_fees + to_user_credit
		if not number_util.float_eq(computed_payment_amount, payment_amount):
			raise errors.Error(f'Sum of transactions and credit to user ({computed_payment_amount}) does not equal payment amount ({payment_amount})', details=err_details)

	def _settle_logic(session: Session) -> bool:
		# Get all contracts associated with company.
		contracts = cast(
			List[models.Contract],
			session.query(models.Contract).filter(
				models.Contract.company_id == company_id
			).all())
		if not contracts:
			raise errors.Error('Cannot settle payment because no contracts are setup for this company')

		contract_dicts = [c.as_dict() for c in contracts]

		contract_helper, err = contract_util.ContractHelper.build(company_id, contract_dicts)
		if err:
			raise err

		active_contract, err = contract_helper.get_contract(settlement_date)
		if err:
			raise err
		if not active_contract:
			raise errors.Error('No active contract on settlement date')

		loan_ids = []
		loans = []
		if is_line_of_credit:
			product_type, err = active_contract.get_product_type()
			if product_type != ProductType.LINE_OF_CREDIT:
				raise errors.Error('Customer is not of Line of Credit product type', details=err_details)

			# TODO(warrenshen):
			# Write a test to check that loans that do not have an origination date
			# set (ex. rejected loans) are NOT fetched.
			# Write a test to check that loans are fetch sorted by origination date.
			loans = cast(
				List[models.Loan],
				session.query(models.Loan).filter(
					models.Loan.company_id == company_id
				).filter(
					models.Loan.origination_date != None
				).filter(
					# Do not fetch loans that have an origination_date
					# in the future relative to this payment's deposit date.
					models.Loan.origination_date <= deposit_date
				).filter(
					models.Loan.closed_at == None
				).order_by(
					models.Loan.origination_date.asc(),
					models.Loan.created_at.asc()
				).all())

			loan_ids = list(map(lambda loan: str(loan.id), loans))
		else:
			loan_ids = items_covered['loan_ids']
			loans = cast(
				List[models.Loan],
				session.query(models.Loan).filter(
					models.Loan.company_id == company_id
				).filter(
					models.Loan.id.in_(loan_ids)
				).all())

			if not loans:
				raise errors.Error('No loans associated with settlement request', details=err_details)

			if len(loans) != len(loan_ids):
				raise errors.Error('Not all loans found in database to settle', details=err_details)

			if len(transaction_inputs) != len(loans):
				raise errors.Error('Unequal amount of transaction inputs provided relative to loans provided', details=err_details)

		for loan in loans:
			if not loan.origination_date:
				raise errors.Error('Loan {} is missing an origination date'.format(loan.id))

			# Do not allow loans that are funded after the deposit date of this payment
			if loan.origination_date > deposit_date:
				raise errors.Error('Cannot fund loan {} which has an origination date of {} with a payment being deposited earlier on {}'.format(
					loan.id, loan.origination_date, deposit_date))

		loan_id_to_loan = {}
		for loan in loans:
			loan_id_to_loan[str(loan.id)] = loan

		transactions = cast(
			List[models.Transaction],
			session.query(models.Transaction).filter(
				models.Transaction.loan_id.in_(loan_ids)
			).all())

		# Get the payments associated with the loan
		all_transaction_dicts = []
		all_payment_ids = []
		if transactions:
			for t in transactions:
				all_transaction_dicts.append(t.as_dict())
				all_payment_ids.append(str(t.payment_id))

		existing_payments = cast(
			List[models.Payment],
			session.query(models.Payment).filter(
				models.Payment.id.in_(all_payment_ids)
			).all())

		all_augmented_transactions, err = models_util.get_augmented_transactions(
			all_transaction_dicts, [p.as_dict() for p in existing_payments]
		)
		if err:
			raise err

		# Do NOT allow settling a new payment for loans if payment.settlement_date is prior to
		# the effective_date of any existing transaction(s) related to the loans.
		#
		# Why? Say we have the following:
		# Loan L with transactions T1, T2, and T3 with the following settlement dates:
		# T1: "10/10/2020"
		# T2: "10/11/2020"
		# T3: "10/16/2020"
		#
		# Proposed payment P with the following settlement date: "10/14/2020".
		#
		# T3 was created with the assumption that the only transactions associated
		# with L are T1 and T2. But if we accept P, this will create a transaction
		# T4 which impacts interest & fees calculations before T3 happen. This means
		# T3 will now be incorrect, since it was created based on T1 and T2 but
		# should be created on T1, T2, and T4.
		effective_dates = [augmented_transaction['transaction']['effective_date'] for augmented_transaction in all_augmented_transactions]
		if len(effective_dates):
			max_transaction_effective_date = max(effective_dates)
			if settlement_date < max_transaction_effective_date:
				raise errors.Error('Cannot settle a new payment for loans since the settlement date is prior to the effective_date of one or more existing transaction(s) of loans')

		payment = cast(
			models.Payment,
			session.query(models.Payment).filter(
				models.Payment.id == payment_id
			).first())

		if not payment:
			raise errors.Error('No payment found to settle transaction', details=err_details)

		if payment.settled_at:
			raise errors.Error('Cannot use this payment because it has already been settled and applied to certain loans', details=err_details)

		if payment.type != db_constants.PaymentType.REPAYMENT:
			raise errors.Error('Can only apply repayments against loans', details=err_details)

		################################
		# Validations
		# Note that we do not enforce payment.deposit_date >= payment.payment_date.
		# This is because the bank may decide to set the deposit date to earlier than the
		# payment date in case the payment date is incorrect.
		################################
		if not payment.payment_date:
			raise errors.Error('Payment must have a payment date')

		# Note: it is important that we use `loan_ids` to create `loan_dicts`.
		# This is because the order of `loan_ids` maps to the order of
		# transactions in `transaction_inputs`.
		loan_dicts = [loan_id_to_loan[loan_id].as_dict() for loan_id in loan_ids]
		loan_dict_and_balance_list: List[LoanDictAndBalance] = []

		# Find the before balances for the loans
		fee_accumulator = fee_util.FeeAccumulator()

		financial_summary = financial_summary_util.get_latest_financial_summary(
			company_id=company_id, session=session
		)
		if financial_summary:
			threshold_info = loan_calculator.ThresholdInfoDict(
				day_threshold_met=financial_summary.day_volume_threshold_met
			)
		else:
			threshold_info = loan_calculator.ThresholdInfoDict(
				day_threshold_met=None
			)

		# We basically want to repeat what happens in the calculate repayment effect logic
		# We want to compute how much will be owed assuming this transaction goes through.
		# We don't want to go negative on interest or principal, hence we compute what would
		# be the outstanding principal, interest and fees, run the transaction and ensure that
		# we don't end up with negative numbers there.
		loan_dict_and_balance_list = []

		if is_line_of_credit:
			payment_amount_to_principal = req['items_covered']['to_principal']
			payment_amount_to_interest = req['items_covered']['to_interest']

			# Apply in the order of earliest maturity date to latest maturity date
			# while trying to cover as much of the loan coming due earliest
			# Also paying off loans and fees takes preference over principal.
			loan_dicts.sort(key=lambda l: (l['adjusted_maturity_date'], l['origination_date'], l['created_at']))

			payment_to_include = loan_calculator.IncludedPaymentDict(
				option=payment_util.RepaymentOption.CUSTOM_AMOUNT_FOR_SETTLING_LOC,
				custom_amount=None,
				custom_amount_split={
					'to_principal': payment_amount_to_principal,
					'to_interest': payment_amount_to_interest,
					'to_fees': None # Not used when settling an LOC loan
				},
				deposit_date=deposit_date,
				settlement_date=settlement_date
			)

			for loan_dict in loan_dicts:
				calculator = loan_calculator.LoanCalculator(contract_helper, fee_accumulator)
				transactions_for_loan = loan_calculator.get_transactions_for_loan(
					loan_dict['id'], all_augmented_transactions)
				calculate_result, errs = calculator.calculate_loan_balance(
					threshold_info,
					loan_dict,
					transactions_for_loan,
					today=settlement_date,
					payment_to_include=payment_to_include,
					should_round_output=False
				)
				if errs:
					raise errors.Error('\n'.join([err.msg for err in errs]))

				before_loan_update = calculate_result['payment_effect']['loan_state_before_payment']
				cur_transaction = calculate_result['payment_effect']['transaction']

				# Keep track of what this loan balance is as of the date that this repayment
				# will settle (so we have to calculate the additional interest and fees that will accrue)
				cur_before_balance = LoanBalanceDict(
						amount=loan_dict['amount'],
						outstanding_principal_balance=before_loan_update['outstanding_principal'],
						outstanding_interest=before_loan_update['outstanding_interest'],
						outstanding_fees=before_loan_update['outstanding_fees']
				)

				if cur_transaction['amount'] <= 0:
					# If there it no amount left to pay (for neither principal nor interest),
					# skip and do not create a TransactionInputDict.
					continue

				loan_dict_and_balance_list.append(LoanDictAndBalance(
					loan=loan_dict,
					before_balance=cur_before_balance
				))

				#print('Before balance {} {} {}'.format(
				#	cur_before_balance['outstanding_principal_balance'],
				#	cur_before_balance['outstanding_interest'],
				#	cur_before_balance['outstanding_fees']
				#))

				transaction_inputs.append(TransactionInputDict(
					amount=cur_transaction['amount'],
					to_principal=cur_transaction['to_principal'],
					to_interest=cur_transaction['to_interest'],
					to_fees=cur_transaction['to_fees']
				))

				#print('Cur transaction {} {} {}'.format(
				#	cur_transaction['to_principal'],
				#	cur_transaction['to_interest'],
				#	cur_transaction['to_fees']
				#))
				#print('')

			# If there is remaining amount to pay (for either principal or interest),
			# this means this repayment is an over-payment.
			amount_to_principal_left = payment_to_include['custom_amount_split']['to_principal']
			amount_to_principal_left = number_util.round_currency(amount_to_principal_left)
			if amount_to_principal_left > 0.0:
				raise errors.Error(
					f'Amount of principal left after payment may not be greater than 0: you must reduce the amount applied to principal by {number_util.to_dollar_format(amount_to_principal_left)}')

			amount_to_interest_left = payment_to_include['custom_amount_split']['to_interest']
			amount_to_interest_left = number_util.round_currency(amount_to_interest_left)

			if amount_to_interest_left > 0.0:
				raise errors.Error(
					f'Amount of interest left after payment may not be greater than 0: you must increase the amount applied to interest by {number_util.to_dollar_format(amount_to_interest_left)}')
		else:
			# The non-LOC case

			for i in range(len(loan_dicts)):
				loan_dict = loan_dicts[i]
				tx_input = transaction_inputs[i]
				# Calculate each loan separately, as there is one transaction specified by the user
				# per loan.
				payment_to_include = loan_calculator.IncludedPaymentDict(
					option=payment_util.RepaymentOption.CUSTOM_AMOUNT_FOR_SETTLING_NON_LOC_LOAN,
					custom_amount=None,
					custom_amount_split={
						'to_principal': tx_input['to_principal'],
						'to_interest': tx_input['to_interest'],
						'to_fees': tx_input['to_fees']
					},
					deposit_date=deposit_date,
					settlement_date=settlement_date
				)
				calculator = loan_calculator.LoanCalculator(contract_helper, fee_accumulator)
				transactions_for_loan = loan_calculator.get_transactions_for_loan(
					loan_dict['id'], all_augmented_transactions)
				calculate_result, errs = calculator.calculate_loan_balance(
					threshold_info,
					loan_dict,
					transactions_for_loan,
					today=settlement_date,
					payment_to_include=payment_to_include,
					should_round_output=True
				)
				if errs:
					raise errors.Error('\n'.join([err.msg for err in errs]))

				before_loan_update = calculate_result['payment_effect']['loan_state_before_payment']

				# Keep track of what this loan balance is as of the date that this repayment
				# will settle (so we have to calculate the additional interest and fees that will accrue)
				loan_dict_and_balance_list.append(LoanDictAndBalance(
					loan=loan_dict,
					before_balance=LoanBalanceDict(
						amount=loan_dict['amount'],
						outstanding_principal_balance=before_loan_update['outstanding_principal'],
						outstanding_interest=before_loan_update['outstanding_interest'],
						outstanding_fees=before_loan_update['outstanding_fees']
					)
				))

		if to_user_credit > 0.0:
			payment_util.create_and_add_credit_to_user(
				amount=to_user_credit,
				payment_id=payment_id,
				created_by_user_id=user_id,
				effective_date=settlement_date,
				session=session
			)

		if to_account_fees > 0.0:
			tx_ids, err = repayment_util_fees.settle_repayment_of_fee(
				req={
					'company_id': company_id,
					'payment_id': payment_id,
					'amount': to_account_fees,
					'deposit_date': date_util.date_to_str(settlement_date),
					'settlement_date': date_util.date_to_str(settlement_date),
					'items_covered': {
						'to_account_fees': to_account_fees,
						'to_user_credit': 0.0 # never set the user credit here because we create it above
					}
				},
				should_settle_payment=False, # because we are part of a larger payment that gets settled at the end of this method
				user_id=user_id,
				session=session
			)
			if err:
				raise err

		for i in range(len(transaction_inputs)):
			tx_input = transaction_inputs[i]
			to_principal = tx_input['to_principal']
			to_interest = tx_input['to_interest']
			to_fees = tx_input['to_fees']

			cur_loan_id = loan_dict_and_balance_list[i]['loan']['id']
			cur_loan = loan_id_to_loan[cur_loan_id]

			# If transaction input is equivalent to zero, skip it.
			# This may happen in the following case:
			# 1. Customer selects loans
			# 2. Customer specifies custom amount to pay
			# 3. Custom amount covers only a subset of selected loans
			# 4. Loan(s) not covered create transaction input(s) that are equivalent to zero.
			if to_principal == 0.0 and to_interest == 0.0 and to_fees == 0.0:
				# Set payment status to None, otherwise it would be left as PaymentStatusEnum.SCHEDULED.
				# It could be that payment status is supposed to be PARTIALLY_PAID... ignore that case for now.
				cur_loan.payment_status = None
				continue

			t = models.Transaction()
			t.type = db_constants.PaymentType.REPAYMENT
			t.amount = decimal.Decimal(tx_input['amount'])
			t.to_principal = decimal.Decimal(number_util.round_currency(tx_input['to_principal']))
			t.to_interest = decimal.Decimal(number_util.round_currency(tx_input['to_interest']))
			t.to_fees = decimal.Decimal(number_util.round_currency(tx_input['to_fees']))
			t.loan_id = cur_loan_id
			t.payment_id = payment_id
			t.created_by_user_id = user_id
			t.effective_date = settlement_date

			balance_before = loan_dict_and_balance_list[i]['before_balance']

			# We use balance_before here since we want to use loan balances
			# as of the payment.settlement_date (which may be in the future).
			new_outstanding_principal_balance = number_util.round_currency(
				balance_before['outstanding_principal_balance'] - to_principal)
			new_outstanding_interest = number_util.round_currency(
				balance_before['outstanding_interest'] - to_interest)
			new_outstanding_fees = number_util.round_currency(
				balance_before['outstanding_fees'] - to_fees)

			#print('=====')
			#print('Loan: {}'.format(cur_loan_id))
			#print('Balance before {}'.format(balance_before))
			#print('To principal: {}. To interest: {}. To fees {}'.format(to_principal, to_interest, to_fees))
			#print('=====')

			if new_outstanding_interest < 0:
				raise errors.Error(
					f'Interest on a loan may not be negative: you must reduce the amount applied to interest on {cur_loan_id} by {-1 * new_outstanding_interest}')

			if new_outstanding_fees < 0:
				raise errors.Error(
					f'Fees on a loan may not be negative after payment: you must reduce the amount applied to fees on {cur_loan_id} by {-1 * new_outstanding_fees}')

			if new_outstanding_principal_balance < 0:
				raise errors.Error(
					f'Principal on a loan may not be negative after payment: you must reduce the amount applied to principal on {cur_loan_id} by {-1 * new_outstanding_principal_balance}')

			session.add(t)

			cur_loan.outstanding_principal_balance = decimal.Decimal(new_outstanding_principal_balance)
			cur_loan.outstanding_interest = decimal.Decimal(new_outstanding_interest)
			cur_loan.outstanding_fees = decimal.Decimal(new_outstanding_fees)

			no_outstanding_balance = payment_util.should_close_loan(
				new_outstanding_principal=new_outstanding_principal_balance,
				new_outstanding_interest=new_outstanding_interest,
				new_outstanding_fees=new_outstanding_fees
			)

			if no_outstanding_balance:
				payment_util.close_loan(cur_loan)
			else:
				cur_loan.payment_status = PaymentStatusEnum.PARTIALLY_PAID

		repayment_identifier = payment_util.get_and_increment_repayment_identifier(company_id, session)

		payment_util.make_repayment_payment_settled(
			payment,
			settlement_identifier=repayment_identifier,
			amount=decimal.Decimal(payment_amount),
			deposit_date=deposit_date,
			settlement_date=settlement_date,
			settled_by_user_id=user_id,
		)

		# TODO(warrenshen): change this to return payment_ids.
		return True

	with session_scope(session_maker) as session:
		_settle_logic(session)

		transactions = cast(
			List[models.Transaction],
			session.query(models.Transaction).filter(
				models.Transaction.payment_id == payment_id
			).all())
		transaction_ids = list(map(lambda transaction: transaction.id, transactions))

	# TODO(warrenshen): change this to return payment_ids.
	# This currently does not return transaction ids of credit_to_user transactions.
	return transaction_ids, None

UndoRepaymentReqDict = TypedDict('UndoRepaymentReqDict', {
	'company_id': str,
	'payment_id': str
})


@errors.return_error_tuple
def undo_repayment(
	req: UndoRepaymentReqDict,
	user_id: str,
	session_maker: Callable
) -> Tuple[bool, errors.Error]:

	with session_scope(session_maker) as session:
		success, err = payment_util.unsettle_payment(
				payment_type=db_constants.PaymentType.REPAYMENT,
				payment_id=req['payment_id'],
				session=session
			)
		if err:
			raise err

	return True, None

DeleteRepaymentReqDict = TypedDict('DeleteRepaymentReqDict', {
	'payment_id': str
})


@errors.return_error_tuple
def delete_repayment(
	req: DeleteRepaymentReqDict,
	user_id: str,
	session_maker: Callable
) -> Tuple[bool, errors.Error]:

	with session_scope(session_maker) as session:
		success, err = payment_util.delete_payment(
			payment_types=[
				db_constants.PaymentType.REPAYMENT,
				db_constants.PaymentType.REPAYMENT_OF_ACCOUNT_FEE,
			],
			payment_id=req['payment_id'],
			session=session
		)
		if err:
			raise err

	return True, None
